<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <title>DOCUMENTO PARCIAL 3</title>
</head>
<body>

  <div class="container">
    <h1>INFORME DE LENGUAJES DE PROGRAMACION</h1>
    <div class="student-info">
      <p>Nombre del Estudiante: Juan Camilo Rodriguez CC.1004614611</p>

    <br><br>
    
    <div class="section" id="corte1">
      <h2>1er Corte</h2>
      <p>¡Haz clic en el contenedor!</p>
      <div style="display: none;">
          <!-- Contenido del 1er Corte -->
          En el 1er corte vimos la programación funcional donde es un paradigma de programación que trata la computación como una evaluación de funciones matemáticas y evita el cambio de estado y datos mutables. En este primer corte que tuvimos, exploraremos tres funciones fundamentales en programación funcional: <strong>map</strong>, <strong>filter</strong>, y <strong>reduce</strong>. Estas funciones son herramientas poderosas que permiten manipular y transformar colecciones de datos de manera concisa y declarativa.
          <ul>
              <li><strong>Función map:</strong> Se utiliza para aplicar una función a cada elemento de una lista y devuelve una nueva lista con los resultados.</li>
              <li><strong>Función filter:</strong> Se utiliza para filtrar elementos de una lista según una condición dada y retorna una nueva lista con los elementos que cumplen con la condición.</li>
              <li><strong>Función reduce:</strong> Se utiliza para aplicar una función acumulativa a los elementos de una lista, de izquierda a derecha, para reducir la lista a un solo valor.</li>
          </ul>
          <br>
          Luego vimos los siguientes paradigmas:
          <ul>
              <li><strong>Imperativo:</strong>
                  <br> <br>
                  Ejemplos: C, Java, Python.
                  <br> <br>
                  Descripción: En la programación imperativa, se le indica a la computadora cómo realizar una tarea paso a paso. Los programas se estructuran en torno a declaraciones que modifican el estado del programa.
              </li>
              <br>
              <li><strong>Declarativo:</strong>
                  <br> <br>
                  Ejemplos: HTML, CSS.
                  <br> <br>
                  Descripción: A diferencia del paradigma imperativo, en la programación declarativa, se describe el resultado deseado sin especificar explícitamente cómo llegar a ese resultado. En lugar de dar instrucciones detalladas, se declaran las propiedades o características que se desean.
              </li>
              <br>
              <li><strong>Estructurado:</strong>
                  <br><br>
                  Elementos:
                  <ul>
                      <li>Condicionales.</li>
                      <li>Ciclos.</li>
                      <li>Procedimental.</li>
                  </ul>
                  <br>
                  Descripción: El paradigma de programación estructurada se centra en la organización lógica y clara del código. Utiliza estructuras como condicionales (if, else), ciclos (for, while) y procedimientos para mejorar la legibilidad y mantenibilidad del código.
                  En resumen, los paradigmas de programación representan enfoques fundamentales para diseñar y estructurar programas. Cada paradigma tiene sus propias características y se elige según los requisitos y preferencias de cada programador.
              </li>
          </ul>
          <br><br>
          <h2>Ejemplos en Python (PROGRAMACION FUNCIONAL):</h2>
          <pre>
            <code>
              # Usando map para duplicar cada elemento de una lista
              original_lista = [1, 2, 3, 4, 5]
              duplicados = list(map(lambda x: x * 2, original_lista))
              print(duplicados)
              # Salida: [2, 4, 6, 8, 10]
  
              # Usando filter para obtener solo los números pares de una lista
              numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
              pares = list(filter(lambda x: x % 2 == 0, numeros))
              print(pares)
              # Salida: [2, 4, 6, 8, 10]
  
              # Usando reduce para obtener la suma de los elementos de una lista
              from functools import reduce
              numeros = [1, 2, 3, 4, 5]
              suma = reduce(lambda x, y: x + y, numeros)
              print(suma)
              # Salida: 15
            </code>
          </pre>
      </div>
  </div>
  

    <br><br><br>
    
    <div class="section" id="corte2">
      <h2>2do Corte</h2>
      <p>!Haz clic en el contenedor¡</p>
      <div style="display: none;">
        La 2do corte hablamos sobre Programación Orientada a Objetos (POO) en Python donde se convierte en un pilar esencial para entender cómo los conceptos fundamentales de la OPP, como clases, objetos, atributos, métodos, encapsulación, asociaciones, generalización y herencia, se entrelazan para crear un software sólido y modular. La modularidad garantiza la división del código en módulos independientes, lo que facilita su comprensión y mantenimiento, mientras que la reutilización y la adaptabilidad destacan su capacidad para ser aprovechado en diferentes contextos y ampliado en funcionalidad. Estos principios se enlazan en el criterio del software, destacando la importancia de la testabilidad, que permite verificar la funcionalidad de cada parte de manera aislada.
        <br><br>
        EJEMPLO BASICO DE POO:

        <pre>
          <code>
              class Persona:
              def __init__(self, nombre, edad):
                self.nombre = nombre
                self.edad = edad

              def imprimir_informacion(self):
                  print(f"Nombre: {self.nombre}, Edad: {self.edad}")

              # Crear una instancia de la clase Persona
              persona1 = Persona("Juan", 21)

              # Acceder a los atributos y llamar al método
              print(persona1.nombre)  # Imprimir el nombre
              print(persona1.edad)    # Imprimir la edad
              persona1.imprimir_informacion()  # Imprimir toda la información
          </code>          
        </pre>
        <br>
        Tambien vimos patrones de diseño creacionales, estructurales y de comportamiento aqui unos conceptos y unos ejemplos sobre eso:
        <br><br>
        <ul>
          <li>
          Singleton (Singleton): Es un patrón de diseño creacional que asegura que una clase tenga una única instancia y proporciona un punto de acceso global a esa instancia. Esto es útil cuando solo se necesita una única instancia para controlar acciones como acceso a bases de datos, configuraciones o recursos compartidos.
          </li>
          <br><br>
          <li>
          Observer (Observador): Es un patron de diseño de comportamiento que permite que un objeto (el sujeto) notifique a otros objetos (los observadores) cuando cambia su estado. Los observadores se suscriben al sujeto y reciben automáticamente notificaciones sobre cualquier modificación, lo que permite mantener la consistencia entre diferentes partes de una aplicación.
          </li>
          <br><br>
          <li>
          Adapter (Adaptador): Es un patron de diseño estructural que sirve como un puente entre dos interfaces incompatibles, permitiendo que objetos con interfaces diferentes trabajen juntos. Convierte la interfaz de una clase en otra que se espera, facilitando la interoperabilidad entre componentes existentes sin modificar su código original.
          </li>
          <br><br>
          <li>
          Factory (Fábrica): Es un patrón de diseño que se utiliza para crear instancias de clases sin especificar directamente la clase exacta que se creará. Proporciona una interfaz para crear objetos en una superclase, permitiendo a las subclases alterar el tipo de objetos que se crearán.
          Cada uno de estos patrones aborda problemas comunes de diseño de software y proporciona soluciones flexibles y reutilizables para esos problemas específicos.
          </li>
          <br><br>
          <li>
          Strategy (Estrategia): Este patrón permite definir un conjunto de algoritmos, encapsular cada uno de ellos y hacerlos intercambiables. Los objetos pueden cambiar su comportamiento en tiempo de ejecución al seleccionar entre diferentes estrategias sin que el cliente que los utiliza necesite conocer los detalles de implementación. Ayuda a separar los algoritmos de su uso, promoviendo la flexibilidad y permitiendo cambiar el comportamiento de un objeto sin alterar su estructura.
          </li>

        </ul>

        EJEMPLOS DE CADA UNO:
<br><br>
        Singleton:
        <pre>
          <code>
    #Singleton - beneficios:
    #1. evitar acceso concurrente a recurso compartido
    #2. tener un punto de acceso global a un recurso

    #formas de implementación

    #Ejemplo de singleton "clásico"

    class ClassicSingleton:

    _instance_ = None

    def __init__(this):
        raise RuntimeError("invocar la función create_instance para crear objeto")
    
    #métodos de instancia
    def enqueueDocument(this, fileName, format):
        pass

    def dispatchDocument(this, fileName):
        pass

    def deleteDocument(this, fileName):
        pass
    
    #un "classmethod es un método estático"
    @classmethod
    def createInstance(this):
        if this._instance_ is None:
            #lo hace solo una vez, cuando no se ha instanciado ningún objeto
            this._instance_ = this.__new__(this) 
            #__new__ lo usa internamente __init__ para crear una nueva instancia de clase
        
                return this._instance_
            
        ######### fin de implementación del singleton

        #tratamos de crear con el método init:
        #printerPool1 = ClassicSingleton()
        #printerPool2 = ClassicSingleton()

        #Ejemplo de uso del singleton clásico:

        printerPool1 = ClassicSingleton.createInstance() #lo llamo como método estático, no
                                                        #método de objeto
        printerPool2 = ClassicSingleton.createInstance()

        print(printerPool1)
        print(printerPool2)

        print(printerPool1 == printerPool2)
          </code>
        </pre>

        <br><br>

        Observer:
        <pre>
          <code>
        from events import Events
        #Clase Publisher que se encarga de actualizar o notificar a los 
        #subscriptores
        class Publisher:
            #Inicializar lista de observadores
            def __init__(this):
                this._observers = []

            def addSubscriber(this, newSubscriber):
                this._observers.append(newSubscriber)

            def removeSubscriber(this, subscriber):
                this._observers.remove(subscriber)

            def notifySubscribers(this,message):
                #enviar message a todos los subscribers en la lista:
                for subscriber in this._observers :
                    subscriber.update(message)

        class Subscriber:

            def Update(this, message):
                pass

        class SubscriberType1(Subscriber):

            def Update(this, message):
                #return super().Update(message)
                print(f"Subscriber 1 recibió mensaje {message}")

        class SubscriberType2(Subscriber):

            def Update(this, message):
                print(f"")

        #Método principal:
        if __name__ == "__main__":

            #crear publisher:
            publisher1 = Publisher()

            #crear subscriptores u "observers"
            observer1 = SubscriberType1()
            observer2 = SubscriberType2()

            #agregar subscriptores:
            publisher1.addSubscriber(observer1)
            publisher1.addSubscriber(observer2)

            #notificar subscriptores:
            publisher1.notifySubscribers("checking my subscribers...")
          </code>
        </pre>

        Adapter:

        <pre>
          <code>
                    #target
        class Pdf_reader:
            def request(self) -> str:
                return "Lector: Lector PDF predeterminado"

        #clase adaptada
        class Document_word:
            def specific_request(self) -> str:
                return "parcial_2.docx"

        #La clase adapter implementa el método que adapta la clase adaptada al target
        class Adapter(Pdf_reader, Document_word):

          def request(self) -> str:
                #función dummy que devuelve el formato correctto, devuelve el dato en el formato del target
                string = self.specific_request().replace(".docx", ".pdf") ###
                return f"Documento cambiado: {string}"

        #client code
        def client_code(lector: "Pdf_reader") -> None:
            print(lector.request())

        if __name__ == "__main__":

            print("Client: Sólo trabajo con documentos pdf:")
            lector = Pdf_reader() #target
            client_code(lector) 
            print("\n")

            adaptee = Document_word() #adaptada
            print("Client: Este documento no es un pdf\n"
                  "Mira, no puedo leerlo:")
            print(f"Document: {adaptee.specific_request()}")

            print("Client: Puedo cambiar el formato de este documento:")
            
            #adptador:
            adapter = Adapter()
            client_code(adapter)
          </code>
        </pre>

        Factory:
        <pre>
          <code>
            
          class TranslateEnglish():
          def __init__(self):
              self.translations  = {"mamá":"mom", "papá":"dad"}
          def translate(self, msg):
              return self.translations.get(msg)

          class TranslateFrench():
          def __init__(self):
              self.translations  = {"mamá":"mére", "papá":"pére"}
          def translate(self, msg):
              return self.translations.get(msg)

          class TranslateGerman():
          def __init__(self):
              self.translations  = {"mamá":"mama", "papá":"papa"}
          def translate(self, msg):
              return self.translations.get(msg)

          class TranslationFactory():
          def __init__(self):
              self.translators = { "English":TranslateEnglish, "French": TranslateFrench, "German":TranslateGerman  }
          def return_translator(self, language):
              return self.translators[language]

          if __name__ == "__main__":

          my_factory = TranslationFactory()
          my_en_translator = my_factory.return_translator("English")
          my_fr_translator = my_factory.return_translator("French")
          my_gr_translator = my_factory.return_translator("German")
          </code>
        </pre>
        <br><br>
        Estrategy:
        <pre>
          <code>
            #from abc import abstractmethod
            from abc  import *

            class IAdapter(ABC):
                @abstractmethod
                def abstract_method1():
                    pass
                
                @abstractmethod
                def abstract_method2():
                    pass




            class Context:
                def __init__(self, strategy):
                    self._strategy = strategy


            """Clase Power: Define los atrtibutos de los ataques (El nombre y el daño que causa)"""

            class Power:
                
                def __init__(self, name, damage, strategy = None):
                    self.name = name
                    self.damage = damage
                    self.strategy = strategy

                def __str__(self):        
                    return f"\nCon el poder {self.name} le has restado a tu enemigo {self.damage} de vida\n"

                

            class Strategy():    
                @abstractmethod
                def Viajes(self):
                    pass


            class StrategyA(Strategy, Power):    
                def __init__(self) -> None:
                    self.name = "ESPADA DE LA VERDAD"
                    self.damage = 25000


            class StrategyB(Strategy, Power):
                def __init__(self) -> None:
                    self.name = "PATADA DE TARZÁN"
                    self.damage = 56000

              
            class StrategyC(Strategy, Power):
                def __init__(self) -> None:
                    self.name = "BOLA DE FUEGO"
                    self.damage = 78000



            if __name__ == "__main__":
                
                poder1 = StrategyA()
                poder2 = StrategyB()
                poder3 = StrategyC()

                opc = int(input("ESCOGE UN PODER DE ATAQUE \nEspada de la verdad: (1)  \nPatada de tarzán: (2)  \nMazo de fuego: (3)"))

                if (opc == 1):
                    print(Power(poder1.name, poder1.damage, strategy=StrategyA))

                elif (opc == 2):
                    print(Power(poder2.name, poder2.damage, strategy=StrategyA))

                elif (opc == 3):
                    print(Power(poder3.name, poder3.damage, strategy=StrategyA))

                else: 
                    print("\nOPCIÓN INCORRECTA")

          </code>
        </pre>
      </div>

    </div>
    
    <br><br><br>

    <div class="section" id="corte3">
      <h2>3er Corte</h2>
      <p>!Haz clic en el contenedor¡</p>
      <div style="display: none;">
        
        En el 3er y ultimo corte hablamos sobre la concurrencia y los hilos. La concurrencia en Java se refiere a la capacidad de ejecutar múltiples tareas de manera simultánea. Los hilos (threads) son la unidad más pequeña de procesamiento que puede ser ejecutada por un sistema operativo. En Java, puedes trabajar con hilos para lograr la concurrencia.
      <br><br>
      EJEMPLO TRABAJANDO CON JAVA CON CONCURRENCIA Y HILOS:

      <PRE>
        <CODE>
          import java.util.Random;
          import java.util.*;

          public class SumaMatrices {

              static int[][] matA = new int[4][4];
              static int[][] matB = new int[4][4];
              static int[][] matC = new int[4][4];

              public static void main(String[] args) {

                  long startTime = System.currentTimeMillis();

                  ColocarValores(matA);
                  ColocarValores(matB);
                  ColocarValores(matC);

                  Thread suma1 = new Thread(() -> SumaMatrices.sumaFila(0));
                  Thread suma2 = new Thread(() -> SumaMatrices.sumaFila(1));
                  Thread suma3 = new Thread(() -> SumaMatrices.sumaFila(2));
                  Thread suma4 = new Thread(() -> SumaMatrices.sumaFila(3));

                  System.out.println("MATRIZ: 1");
                  imprimirFila(matA);

                  System.out.println("MATRIZ: 2");
                  imprimirFila(matB);

                  System.out.println("MATRIZ: 3");
                  imprimirFila(matC);

                  long endTime = System.currentTimeMillis() - startTime;
                  System.out.println("tiempo " + endTime + " milisegundos");

              }

              public static void sumaFila(int fila) {

                  for (int i = 0; i < 4; i++) {
                      matC[fila][i] = matA[fila][i] + matB[fila][i];
                      matC[fila][i] = matA[fila][i] + matB[fila][i];
                      matC[fila][i] = matA[fila][i] + matB[fila][i];
                      matC[fila][i] = matA[fila][i] + matB[fila][i];
                  }
              }

              public static void imprimirFila(int[][] matriz) {
                  for (int i = 0; i < 4; i++) {
                      for (int j = 0; j < 4; j++) {
                          System.out.print("[" + matriz[i][j] + "]");

                      }
                      System.out.println("\n");
                  }

              }

              public static void ColocarValores(int[][] matriz) {
                  Random aleatorios = new Random();
                  for (int filas = 0; filas < 4; filas++) {
                      matriz[filas][0] = 1 + aleatorios.nextInt(101);
                      matriz[filas][1] = 1 + aleatorios.nextInt(101);
                      matriz[filas][2] = 1 + aleatorios.nextInt(101);
                      matriz[filas][3] = 1 + aleatorios.nextInt(101);
                  }
              }

          }

        </CODE>
      </PRE>
        Como vemos en el codigo recorremos los hilos por cada fila para asi hacer la suma de matrices.
      
      </div>
    </div>
  </div>

  <script src="script.js"></script>
</body>
</html>
